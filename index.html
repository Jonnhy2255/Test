<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aventure H√©ro√Øque - Style Zelda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        grass: '#4ade80',
                        water: '#3b82f6',
                        rock: '#6b7280',
                        hero: '#ef4444',
                        enemy: '#f59e0b',
                        npc: '#8b5cf6'
                    }
                }
            }
        }
    </script>
    <style>
        .game-tile {
            width: 32px;
            height: 32px;
            position: absolute;
            transition: all 0.2s ease;
        }
        
        .hero {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            border: 2px solid #991b1b;
            z-index: 10;
        }
        
        .hero::before {
            content: '‚öîÔ∏è';
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
        }
        
        .enemy {
            background: linear-gradient(45deg, #f59e0b, #d97706);
            border-radius: 50%;
            border: 2px solid #92400e;
            z-index: 5;
        }
        
        .enemy::before {
            content: 'üëπ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
        }
        
        .npc {
            background: linear-gradient(45deg, #8b5cf6, #7c3aed);
            border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%;
            border: 2px solid #5b21b6;
            z-index: 5;
        }
        
        .npc::before {
            content: 'üßô‚Äç‚ôÇÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
        }
        
        .treasure {
            background: linear-gradient(45deg, #fbbf24, #f59e0b);
            border-radius: 20%;
            border: 2px solid #d97706;
            z-index: 3;
        }
        
        .treasure::before {
            content: 'üíé';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
        }
        
        .tree {
            background: linear-gradient(180deg, #16a34a 0%, #16a34a 60%, #92400e 60%, #92400e 100%);
            border-radius: 50% 50% 50% 50% / 80% 80% 20% 20%;
            border: 2px solid #15803d;
        }
        
        .rock {
            background: linear-gradient(45deg, #6b7280, #4b5563);
            border-radius: 30%;
            border: 2px solid #374151;
        }
        
        .water {
            background: linear-gradient(45deg, #3b82f6, #2563eb);
            border-radius: 20%;
            border: 2px solid #1d4ed8;
            animation: water-shimmer 2s ease-in-out infinite;
        }
        
        @keyframes water-shimmer {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .damage-text {
            position: absolute;
            color: #ef4444;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            animation: damage-float 1s ease-out forwards;
            z-index: 20;
        }
        
        @keyframes damage-float {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        
        .dark .hero { background: linear-gradient(45deg, #dc2626, #b91c1c); }
        .dark .enemy { background: linear-gradient(45deg, #d97706, #b45309); }
        .dark .npc { background: linear-gradient(45deg, #7c3aed, #6d28d9); }
        .dark .treasure { background: linear-gradient(45deg, #f59e0b, #d97706); }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 overflow-hidden">
    <div id="gameContainer" class="relative w-full h-screen bg-gradient-to-br from-green-200 to-green-400 dark:from-green-800 dark:to-green-900">
        <!-- Interface utilisateur -->
        <div class="absolute top-4 left-4 z-30 bg-white dark:bg-gray-800 rounded-lg p-4 shadow-lg">
            <div class="text-lg font-bold text-gray-800 dark:text-white">‚öîÔ∏è H√©ros</div>
            <div class="flex items-center gap-2 mt-1">
                <span class="text-sm text-gray-600 dark:text-gray-300">PV:</span>
                <div class="w-20 h-2 bg-gray-200 dark:bg-gray-600 rounded-full overflow-hidden">
                    <div id="heroHealth" class="h-full bg-red-500 transition-all duration-300" style="width: 100%"></div>
                </div>
                <span id="heroHealthText" class="text-sm font-bold text-gray-800 dark:text-white">100/100</span>
            </div>
            <div class="text-sm text-gray-600 dark:text-gray-300 mt-1">
                Score: <span id="score" class="font-bold text-primary">0</span>
            </div>
        </div>

        <!-- Contr√¥les mobiles -->
        <div class="absolute bottom-4 left-4 z-30 md:hidden">
            <div class="grid grid-cols-3 gap-1 w-32 h-32">
                <div></div>
                <button id="upBtn" class="bg-primary text-white rounded-lg font-bold text-xl">‚Üë</button>
                <div></div>
                <button id="leftBtn" class="bg-primary text-white rounded-lg font-bold text-xl">‚Üê</button>
                <div></div>
                <button id="rightBtn" class="bg-primary text-white rounded-lg font-bold text-xl">‚Üí</button>
                <div></div>
                <button id="downBtn" class="bg-primary text-white rounded-lg font-bold text-xl">‚Üì</button>
                <div></div>
            </div>
        </div>

        <div class="absolute bottom-4 right-4 z-30 md:hidden">
            <button id="attackBtn" class="bg-red-500 text-white rounded-full w-16 h-16 font-bold text-xl">‚öîÔ∏è</button>
        </div>

        <!-- Instructions -->
        <div class="absolute top-4 right-4 z-30 bg-white dark:bg-gray-800 rounded-lg p-4 shadow-lg max-w-xs">
            <h3 class="font-bold text-gray-800 dark:text-white mb-2">Instructions</h3>
            <div class="text-sm text-gray-600 dark:text-gray-300 space-y-1">
                <div>üéÆ WASD ou fl√®ches pour bouger</div>
                <div>‚öîÔ∏è Espace pour attaquer</div>
                <div>üéØ D√©fends-toi contre les ennemis</div>
                <div>üíé Collecte les tr√©sors</div>
                <div>üßô‚Äç‚ôÇÔ∏è Parle aux PNJ</div>
            </div>
        </div>

        <!-- Zone de jeu -->
        <div id="gameWorld" class="absolute inset-0" style="width: 800px; height: 600px; background: linear-gradient(45deg, #84cc16 0%, #65a30d 25%, #16a34a 50%, #15803d 75%, #14532d 100%);">
        </div>

        <!-- Messages -->
        <div id="messageBox" class="absolute bottom-20 left-1/2 transform -translate-x-1/2 z-30 bg-white dark:bg-gray-800 rounded-lg p-4 shadow-lg hidden max-w-md">
            <div id="messageText" class="text-gray-800 dark:text-white"></div>
        </div>
    </div>

    <script>
        // Support du mode sombre
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        class Game {
            constructor() {
                this.gameWorld = document.getElementById('gameWorld');
                this.hero = null;
                this.enemies = [];
                this.npcs = [];
                this.treasures = [];
                this.obstacles = [];
                this.score = 0;
                this.heroStats = { health: 100, maxHealth: 100, attack: 25 };
                this.worldWidth = 800;
                this.worldHeight = 600;
                this.tileSize = 32;
                
                this.keys = {};
                this.lastAttackTime = 0;
                this.attackCooldown = 500;
                
                this.init();
                this.setupControls();
                this.gameLoop();
            }
            
            init() {
                this.createWorld();
                this.createHero();
                this.createEnemies();
                this.createNPCs();
                this.createTreasures();
            }
            
            createWorld() {
                // Cr√©er des obstacles (arbres, rochers, eau)
                const obstaclePositions = [
                    // Arbres
                    {x: 100, y: 100, type: 'tree'},
                    {x: 200, y: 150, type: 'tree'},
                    {x: 500, y: 200, type: 'tree'},
                    {x: 600, y: 400, type: 'tree'},
                    {x: 300, y: 450, type: 'tree'},
                    
                    // Rochers
                    {x: 400, y: 100, type: 'rock'},
                    {x: 150, y: 300, type: 'rock'},
                    {x: 650, y: 150, type: 'rock'},
                    {x: 50, y: 500, type: 'rock'},
                    
                    // Eau
                    {x: 350, y: 300, type: 'water'},
                    {x: 382, y: 300, type: 'water'},
                    {x: 350, y: 332, type: 'water'},
                    {x: 382, y: 332, type: 'water'},
                    {x: 750, y: 50, type: 'water'},
                    {x: 750, y: 82, type: 'water'},
                ];
                
                obstaclePositions.forEach(pos => {
                    const obstacle = document.createElement('div');
                    obstacle.className = `game-tile ${pos.type}`;
                    obstacle.style.left = pos.x + 'px';
                    obstacle.style.top = pos.y + 'px';
                    this.gameWorld.appendChild(obstacle);
                    this.obstacles.push({
                        x: pos.x,
                        y: pos.y,
                        width: this.tileSize,
                        height: this.tileSize,
                        type: pos.type
                    });
                });
            }
            
            createHero() {
                this.hero = document.createElement('div');
                this.hero.className = 'game-tile hero';
                this.hero.style.left = '64px';
                this.hero.style.top = '64px';
                this.gameWorld.appendChild(this.hero);
                this.heroPos = {x: 64, y: 64};
            }
            
            createEnemies() {
                const enemyPositions = [
                    {x: 300, y: 200},
                    {x: 500, y: 350},
                    {x: 700, y: 300},
                    {x: 150, y: 450},
                    {x: 600, y: 100}
                ];
                
                enemyPositions.forEach((pos, index) => {
                    const enemy = document.createElement('div');
                    enemy.className = 'game-tile enemy';
                    enemy.style.left = pos.x + 'px';
                    enemy.style.top = pos.y + 'px';
                    this.gameWorld.appendChild(enemy);
                    
                    this.enemies.push({
                        element: enemy,
                        x: pos.x,
                        y: pos.y,
                        health: 50,
                        maxHealth: 50,
                        attack: 15,
                        speed: 1,
                        lastAttack: 0,
                        direction: Math.random() * Math.PI * 2,
                        changeDirectionTime: 0
                    });
                });
            }
            
            createNPCs() {
                const npcPositions = [
                    {x: 250, y: 50, message: "üßô‚Äç‚ôÇÔ∏è Salut aventurier ! Attention aux monstres !"},
                    {x: 750, y: 250, message: "üßô‚Äç‚ôÇÔ∏è Les tr√©sors te donneront de la force !"},
                    {x: 50, y: 350, message: "üßô‚Äç‚ôÇÔ∏è Utilise tes comp√©tences de combat !"}
                ];
                
                npcPositions.forEach((pos, index) => {
                    const npc = document.createElement('div');
                    npc.className = 'game-tile npc';
                    npc.style.left = pos.x + 'px';
                    npc.style.top = pos.y + 'px';
                    this.gameWorld.appendChild(npc);
                    
                    this.npcs.push({
                        element: npc,
                        x: pos.x,
                        y: pos.y,
                        message: pos.message
                    });
                });
            }
            
            createTreasures() {
                const treasurePositions = [
                    {x: 450, y: 50},
                    {x: 100, y: 200},
                    {x: 700, y: 500},
                    {x: 400, y: 500}
                ];
                
                treasurePositions.forEach((pos, index) => {
                    const treasure = document.createElement('div');
                    treasure.className = 'game-tile treasure';
                    treasure.style.left = pos.x + 'px';
                    treasure.style.top = pos.y + 'px';
                    this.gameWorld.appendChild(treasure);
                    
                    this.treasures.push({
                        element: treasure,
                        x: pos.x,
                        y: pos.y,
                        collected: false
                    });
                });
            }
            
            setupControls() {
                // Contr√¥les clavier
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ') {
                        e.preventDefault();
                        this.attack();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Contr√¥les mobiles
                ['upBtn', 'downBtn', 'leftBtn', 'rightBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        const direction = id.replace('Btn', '');
                        btn.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            this.keys[direction] = true;
                        });
                        btn.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            this.keys[direction] = false;
                        });
                    }
                });
                
                const attackBtn = document.getElementById('attackBtn');
                if (attackBtn) {
                    attackBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.attack();
                    });
                }
            }
            
            moveHero() {
                const speed = 3;
                let newX = this.heroPos.x;
                let newY = this.heroPos.y;
                
                if (this.keys['w'] || this.keys['arrowup'] || this.keys['up']) newY -= speed;
                if (this.keys['s'] || this.keys['arrowdown'] || this.keys['down']) newY += speed;
                if (this.keys['a'] || this.keys['arrowleft'] || this.keys['left']) newX -= speed;
                if (this.keys['d'] || this.keys['arrowright'] || this.keys['right']) newX += speed;
                
                // V√©rifier les limites du monde
                newX = Math.max(0, Math.min(this.worldWidth - this.tileSize, newX));
                newY = Math.max(0, Math.min(this.worldHeight - this.tileSize, newY));
                
                // V√©rifier les collisions
                if (!this.checkCollision(newX, newY, this.obstacles)) {
                    this.heroPos.x = newX;
                    this.heroPos.y = newY;
                    this.hero.style.left = this.heroPos.x + 'px';
                    this.hero.style.top = this.heroPos.y + 'px';
                }
            }
            
            checkCollision(x, y, objects) {
                for (let obj of objects) {
                    if (x < obj.x + obj.width &&
                        x + this.tileSize > obj.x &&
                        y < obj.y + obj.height &&
                        y + this.tileSize > obj.y) {
                        return true;
                    }
                }
                return false;
            }
            
            moveEnemies() {
                const currentTime = Date.now();
                
                this.enemies.forEach(enemy => {
                    // Changer de direction parfois
                    if (currentTime - enemy.changeDirectionTime > 2000) {
                        enemy.direction = Math.random() * Math.PI * 2;
                        enemy.changeDirectionTime = currentTime;
                    }
                    
                    // Se diriger vers le h√©ros si proche
                    const distToHero = Math.sqrt(
                        Math.pow(enemy.x - this.heroPos.x, 2) + 
                        Math.pow(enemy.y - this.heroPos.y, 2)
                    );
                    
                    if (distToHero < 100) {
                        const angle = Math.atan2(this.heroPos.y - enemy.y, this.heroPos.x - enemy.x);
                        enemy.direction = angle;
                    }
                    
                    const newX = enemy.x + Math.cos(enemy.direction) * enemy.speed;
                    const newY = enemy.y + Math.sin(enemy.direction) * enemy.speed;
                    
                    // V√©rifier les limites et collisions
                    if (newX >= 0 && newX <= this.worldWidth - this.tileSize &&
                        newY >= 0 && newY <= this.worldHeight - this.tileSize &&
                        !this.checkCollision(newX, newY, this.obstacles)) {
                        enemy.x = newX;
                        enemy.y = newY;
                        enemy.element.style.left = enemy.x + 'px';
                        enemy.element.style.top = enemy.y + 'px';
                    } else {
                        enemy.direction = Math.random() * Math.PI * 2;
                    }
                    
                    // Attaquer le h√©ros si proche
                    if (distToHero < 40 && currentTime - enemy.lastAttack > 1000) {
                        this.damageHero(enemy.attack);
                        enemy.lastAttack = currentTime;
                    }
                });
            }
            
            attack() {
                const currentTime = Date.now();
                if (currentTime - this.lastAttackTime < this.attackCooldown) return;
                
                this.lastAttackTime = currentTime;
                
                // Effet visuel d'attaque
                this.hero.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    this.hero.style.transform = 'scale(1)';
                }, 200);
                
                // V√©rifier les ennemis √† port√©e
                this.enemies.forEach((enemy, index) => {
                    const distance = Math.sqrt(
                        Math.pow(enemy.x - this.heroPos.x, 2) + 
                        Math.pow(enemy.y - this.heroPos.y, 2)
                    );
                    
                    if (distance < 50) {
                        enemy.health -= this.heroStats.attack;
                        this.showDamage(enemy.x, enemy.y, this.heroStats.attack);
                        
                        if (enemy.health <= 0) {
                            enemy.element.remove();
                            this.enemies.splice(index, 1);
                            this.score += 100;
                            this.updateScore();
                        }
                    }
                });
            }
            
            damageHero(damage) {
                this.heroStats.health -= damage;
                this.heroStats.health = Math.max(0, this.heroStats.health);
                this.updateHeroHealth();
                this.showDamage(this.heroPos.x, this.heroPos.y, damage);
                
                // Effet visuel de d√©g√¢ts
                this.hero.style.filter = 'brightness(0.5)';
                setTimeout(() => {
                    this.hero.style.filter = 'brightness(1)';
                }, 200);
                
                if (this.heroStats.health <= 0) {
                    this.gameOver();
                }
            }
            
            showDamage(x, y, damage) {
                const damageText = document.createElement('div');
                damageText.className = 'damage-text';
                damageText.textContent = `-${damage}`;
                damageText.style.left = (x + 16) + 'px';
                damageText.style.top = y + 'px';
                this.gameWorld.appendChild(damageText);
                
                setTimeout(() => {
                    damageText.remove();
                }, 1000);
            }
            
            checkInteractions() {
                // V√©rifier les tr√©sors
                this.treasures.forEach((treasure, index) => {
                    if (!treasure.collected) {
                        const distance = Math.sqrt(
                            Math.pow(treasure.x - this.heroPos.x, 2) + 
                            Math.pow(treasure.y - this.heroPos.y, 2)
                        );
                        
                        if (distance < 30) {
                            treasure.collected = true;
                            treasure.element.remove();
                            this.score += 50;
                            this.heroStats.health = Math.min(this.heroStats.maxHealth, this.heroStats.health + 20);
                            this.updateScore();
                            this.updateHeroHealth();
                            this.showMessage("üíé Tr√©sor collect√© ! +20 PV");
                        }
                    }
                });
                
                // V√©rifier les PNJ
                this.npcs.forEach(npc => {
                    const distance = Math.sqrt(
                        Math.pow(npc.x - this.heroPos.x, 2) + 
                        Math.pow(npc.y - this.heroPos.y, 2)
                    );
                    
                    if (distance < 40) {
                        this.showMessage(npc.message);
                    }
                });
            }
            
            showMessage(text) {
                const messageBox = document.getElementById('messageBox');
                const messageText = document.getElementById('messageText');
                messageText.textContent = text;
                messageBox.classList.remove('hidden');
                
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 3000);
            }
            
            updateHeroHealth() {
                const healthBar = document.getElementById('heroHealth');
                const healthText = document.getElementById('heroHealthText');
                const percentage = (this.heroStats.health / this.heroStats.maxHealth) * 100;
                
                healthBar.style.width = percentage + '%';
                healthText.textContent = `${this.heroStats.health}/${this.heroStats.maxHealth}`;
            }
            
            updateScore() {
                document.getElementById('score').textContent = this.score;
            }
            
            gameOver() {
                this.showMessage("üíÄ Game Over ! Rechargez pour recommencer.");
                // Arr√™ter le jeu
                this.gameRunning = false;
            }
            
            gameLoop() {
                if (this.gameRunning === false) return;
                
                this.moveHero();
                this.moveEnemies();
                this.checkInteractions();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // D√©marrer le jeu
        const game = new Game();
    </script>
</body>
</html>
